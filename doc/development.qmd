---
title: "Development"
format: 
  html: 
    toc: true
    number-sections: true
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

*NB: The following documentation assumes you have basic notions of how to build a RShiny app. Follow the documentations of [RShiny](https://shiny.posit.co/) and [Mastering Shiny](https://mastering-shiny.org/) for more explanations on Shiny, and for some practical examples.*

# Installation

Check the README.md of [SingleCellViz](https://github.com/metzger-chambon/singlecellviz) to install the app locally for development. 
You will need to have the database locally as well. TODO maybe have a small example for testing purpose

Once you have your local version of the app, you can run it with the code in `dev/run_dev.R`. 

# Structure 

## Generalities

The app follows the structure proposed by the R package [golem](https://thinkr-open.github.io/golem/) and their associated [documentation](https://engineering-shiny.org/) on developing production-grade Shiny Apps.

In practice, this means that it uses shiny modules to separate the app code in smaller parts. The modules are under `R/mod_*.R`, there is one for each tab of the app, and for some other features like choosing the dataset `R/mod_dataset.R` or downloading it `R/mod_download.R`. Moreover, some useful common functions are under `R/fct_*.R`, for example, for generating the plots and tables.

*NB: Although the app follows golem guidelines, it cannot be built like an R package directly as it is dependent on large datasets that cannot be saved into a package.*

## Description of the repository

Here is the general structure of the repository:

```{bash, eval = FALSE}
├── app.R
├── data
│   ├── dataset_summary.txt
│   ├── db
│   └── script
├── DESCRIPTION
├── dev
│   ├── 01_start.R
│   ├── 02_dev.R
│   ├── 03_deploy.R
│   ├── config_attachment.yaml
│   └── run_dev.R
├── doc
    ├── deployment.Rmd
    ├── development.Rmd
    └── usage.Rmd
├── inst
│   ├── app
│   ├── golem-config.yml
│   └── WORDLIST
├── LICENSE
├── LICENSE.md
├── man
│   ├── figures
│   └── run_app.Rd
├── NAMESPACE
├── NEWS.md
├── R
│   ├── app_config.R
│   ├── app_server.R
│   ├── app_ui.R
│   ├── _disable_autoload.R
│   ├── fct_*.R
│   ├── golem_utils_server.R
│   ├── golem_utils_ui.R
│   ├── mod_*.R
│   ├── R6.R
│   └── run_app.R
├── README.md
├── README.Rmd
├── renv
│   ├── activate.R
│   ├── settings.json
│   └── staging
├── renv.lock
├── singlecellviz.Rproj
├── tests
│   ├── spelling.R
│   ├── testthat
│   └── testthat.R
```

Here is a quick description of some important content inside of the app repository:

-   `app.R` file contains code to launch the app when deployed on the server (see [golem doc](https://engineering-shiny.org/deploy.html#deploying-apps-with-golem))
-   `data` folder contains the file `dataset_summary.txt` that describes all datasets for the app, the folder `db` with subfolders for each dataset, and the folder `script` with some useful scripts to add datasets (see the section called [Adding a new dataset])
-   `doc` folder contains some documentation about the app
-   `NEWS.md` file contains all updates made to the app
-   `R` folder contains all R scripts for the app to work (see the section called [Description of `R/` scripts])
-   `renv` folder and `renv.lock` file are generated from using the renv library (see the section called [renv (mandatory)](#renv-mandatory))
-   `tests` folder contains automatic tests of the app behavior (see [golem doc](https://engineering-shiny.org/build-app-golem.html?q=test#add-tests))

*NB: for more information about other folders specific to golem structure (e.g. `inst`, `dev`, `man`), check out the [golem documentation](https://engineering-shiny.org/golem.html?q=man#understanding-golem-app-structure).*

## Description of `R/` scripts

-   `run_app.R` contains the function to run the app for the server, it is also where the cache directory is defined
-   `app_config.R` TODO
-   `app_ui.R` and `app_server.R` contains respectively the ui and server main code of the app (this is where each module function is called)
-   `mod_*.R` contains independent code parts of the app, there is one for each tab of the app, and for some other features like choosing the dataset or downloading it (see the section called [Development of modules] for more information)
-   `fct_*.R` contains useful common functions for example for handling plots or tables
-   `golem_utils_*.R` contains general utility functions relative to ui or server handling
-   `R6.R` contains the definition of the DATA class (see the section called [R6 object, COMMON_DATA] for more information)

# Modules and functions

## Description of existing modules

- `mod_` TODO
- 


## Description of existing functions / utils

- `fct_` TODO also give link to this sections in the generalies for example
- 


## Create a new module

To create a new module, run `golem::add_module(name = "your_new_module_name", with_test = TRUE)`, it will create the R scripts in the `R/` folder, as well as tests in the `tests` folder (see the section called [testthat (optional)](#testthat-optional) for more information on tests).

You can add the `module_*_ui.R` and `module_*_server.R` functions to respectively `app_ui.R` and `app_server.R`.

Follow [golem doc](https://engineering-shiny.org/structuring-project.html?q=petit%20r#using-shiny-modules) and [Shiny doc](https://mastering-shiny.org/scaling-modules.html) for more practical information on how to develop modules.

In this app, there are two objects you might need when developing a new module : `r` and `COMMON_DATA`, the two following sections ([reactiveValue object, r] and [R6 object, COMMON_DATA]) describes these objects and their usage.

## reactiveValue object, r

Modules might have the `r` object as parameter. It is a global reactiveValues (see [Shiny](http://rstudio.github.io/shiny/reference/reactiveValues.html) and [golem](https://engineering-shiny.org/structuring-project.html?q=petit%20r#b.-the-strat%C3%A9gie-du-petit-r) doc). It is a special list with elements:

-   `tabs`, the name of the current tab in use
-   `selected_study`, the number of the current selected study

The particularity of reactiveValues objects is that every time the object gets updated, the parts of code that are dependent on them gets recomputed. So if you might need to use: 

- `r$selected_study` if the output of a function is dependent on the dataset
- `r$tabs` if you only want to update an output when on a specific tab

## R6 object, COMMON_DATA

Modules might have the `COMMON_DATA` object as parameter. It is a R6 object (see [R6](https://r6.r-lib.org/articles/Introduction.html) and [golem](https://engineering-shiny.org/structuring-project.html?q=petit%20r#c.-the-strat%C3%A9gie-du-grand-r6) doc).

It contains the public methods:

-   `output`, the value of the uri of the current study
-   `tabs_updated`, a list of value of the latest study shown for each tab

and the active methods:

-   `experiment`, returns an opened SOMA
-   `groups`, returns the name of available groups, which would be the equivalent of Seurat Assays (e.g. RNA)
-   `arrays`, returns the name of available arrays, which would be the equivalent of Seurat slots (e.g. count)
-   `markers`, returns the name of available `markers` tables
-   `comparison`, returns the name of available `comparison` tables


The particularity of R6 objects is that if it modified inside of a function, the modified value is kept outside the function when it is called. So if you develop a module and need some data to be passed to other modules, without the need for reactivity, you will likely have to use the `COMMON_DATA` object.

# Database

The app relies on a database, under the folder `data/db/` where each dataset has its own folder. For each dataset, there should be:

- `config.yaml` file containing metadata about the dataset such as the title, the description, etc (see section [Adding a new dataset])
- `create_rds.R` file containing the script that cleans and process the original data into a compatible dataset for the app
- `${DATASET_NAME}.rds` file containing the Seurat object, the marker and comparison tables that the user will be able to directly download in the app
- `tiledb/` folder containing various folders and files corresponding to the tiledb database (this folder should not be modified manually)

The following sections will describe the structure of the database (sections [TileDB-SOMA] and [rds object]), and how to add a new dataset in the right format (section [Adding a new dataset]).

## TileDB-SOMA

The datasets are saved in in the format provided by [TileDB-SOMA](https://single-cell-data.github.io/TileDB-SOMA/index.html).

TileDB-SOMA is a R package developed to store and access single-cell data at scale. 
Indeed, when working with Seurat object, the whole object is loaded, even though only parts of it are needed (not all genes are going to be visualized for example). 

In addition to the [original TileDB-SOMA structure](https://single-cell-data.github.io/TileDB-SOMA/articles/soma-objects.html) for Seurat objects, the app adds on the two following SOMACollections:

- `marker`
- `comparison` 

Both contains two tables:

- `result`, the result of Seurat's `FindAllMarkers` (for `marker`) or Seurat's `FindMarkers` (for `comparison`)
- `aggrexpression`, the result of Seurat's `AggregateExpression`

## rds object

The rds object is the one that the user will be able to download in the app. It is a list of the following elements:

- `seurat`, the Seurat object
- `marker`, a list with the table of `FindAllMarkers` and `AggregateExpression`
- `comparison`, a list with the table of `FindMarkers` and `AggregateExpression`

It is created from the corresponding `create_rds.R` script, using functions in `data/script/process_seurat_obj.R`.

## Adding a new dataset

Take a look at the `create_rds.R` and `config.yaml` of existing datasets to see how you can easily clean the Seurat object, create necessary tables and convert to TileDB-SOMA format. At the end, add the dataset to `data/dataset_summary.txt` by running `data/db/script/update_summary.R`.

For more explanation, read the following sections. 

### Cleaning the Seurat object

To add a new dataset you will need to clean the Seurat object, for example check that:

- there is no unnecessary columns in `@meta.data`
- that the columns in `@meta.data` are in the expected format (generally `numeric` or `factors`)
- remove unnecessary elements in `@reductions`
- remove unnecessary elements in `@assays`, there should only be one at the end (typically `RNA`) which is the one used for the explore tab (for the DimPlot, VlnPlot, DotPlot)
- remove `scale.data` of the `@assays` left (it is usually very heavy, and not useful for visualization, although you should keep it for running `AggregateExpression` which results is used for the `marker` and `comparison` heatmaps)

### Create marker and comparison tables

To ease the process of creating the tables, the functions `compute_marker` and `compute_comparison` have been developed. They are available in `data/script/process_seurat_obj.R`. 

It takes as input a seurat object, and a list with markers/comparisons to compute. 
The parameters can also bethen be retrieved/saved in yaml format inside of the `config.yaml` (see section [Creating config.yaml]).

For `compute_marker` the list is of the following format:

```{r, eval=FALSE}
optMarkers <- list(
  list(
    name = "CellType markers",
    Ident = "CellType",
    FindAllMarkers = list(only.pos = TRUE,
                         min.pct = 0.25,
                         logfc.threshold = 0.5),
    AggregateExpression = list(assays = "RNA",
                              slot = "scale.data",
                              group.by = c("CellType", "orig.ident")
                          )
  ), 
  list(
    name = "CellType markers",
    ...
  )
)
```

It's a list, where each element defines an instance of `FindAllMarkers` to run. Each element has a value:

- `name`, a string being the name that will appear in the app
- `Ident`, a string being one of the Idents of the Seurat object to run `FindAllMarkers` on
- `FindAllMarkers`, a list with all possible parameters of `FindAllMarkers` function. Only the parameter `object` is given by default. The name of each element in the list is the name of parameters of the function, and its value is the value to give to the parameters. 
- `AggregateExpression`, a list with all possible parameters of `AggregateExpression` function. Only the parameter `object` is given by default.  The name of each element in the list is the name of parameters of the function, and its value is the value to give to the parameters. 

For `compute_comparison` the list is of the following format:

```{r, eval=FALSE}
optMarkers <- list(
  list(
    name = "First comparison",
    subset = list(
      subset = substitute(CellType %in% c("Luminal C"))
      ),
    Ident = "orig.ident",
    FindMarkers = list(ident.1 = PTEN),
    AggregateExpression = list(assays = "RNA",
                              slot = "scale.data",
                              group.by = c("orig.ident", "CellType")
                          )
  ), 
  
  list(
    name = "Second comparison",
    ...
  )
)
```


It's a list, where each element defines an instance of `FindMarkers` to run. Each element has a value:

- `name`, a string being the name that will appear in the app
- `subset`, a list with all possible parameters of `subset` function. Only the parameter `x` is given by default. The name of each element in the list is the name of parameters of the function, and its value is the value to give to the parameters.
- `Ident`, a string being one of the Idents of the Seurat object to run `FindMarkers` on
- `FindMarkers`, a list with all possible parameters of `FindMarkers` function. Only the parameter `object` is given by default. The name of each element in the list is the name of parameters of the function, and its value is the value to give to the parameters.
- `AggregateExpression`, a list with all possible parameters of `AggregateExpression` function. Only the parameter `object` is given by default.  The name of each element in the list is the name of parameters of the function, and its value is the value to give to the parameters. 


It gives as output a list of two elements:
- `table` being the result of `FindAllMarkers` or `FindMarkers` 
- `aggrexpression` being the results of `AggregateExpression`.


### Creating the rds

The `rds` object structure is described in [rds object]. If you followed the previous sections, you only have to create a list like so:

```{r, eval = FALSE}
list(seuratObj = x, 
     markers = y, 
     comparison = z)
```

where `x` is the cleaned Seurat object, `y` is the result of `compute_marker` and `z` is the result of `compute_comparison`.

### Creating config.yaml 

You then need to save this list under `data/db/${DATASET_NAME}/${DATASET_NAME}.rds`, and create the `config.yaml`, that has the following structure, and at least the following elements:

```{bash, eval = FALSE}
title: 'Some string as title of the dataset'
rds: path/of/the/rds/object
output_folder: path/of/the/tiledb/folder
description: 'Some string describing the dataset'
doi: 'Some string being a doi'
date: DD/MM/YYYY
force: boolean (true or false)
```

Optionally, you can add the parameters used for `compute_marker` and `compute_comparison` in this format:
```{bash, eval = FALSE}
markers:
- name: CellType markers
  Ident: CellType
  FindAllMarkers:
    only.pos: yes
  AggregateExpression:
    assays: RNA
    slot: scale.data
    group.by:
    - CellType
    - orig.ident
```

This can be achieved with the code `cat(yaml::as.yaml(optMarkers))` where `optMarkers` is the list of the parameters.

### Creating tiledb

The TileDB-SOMA database can be easily created with the function `populate_tiledb` of `data/script/populate_tiledb.R`. 

It takes as input the path of the `config.yaml` file, and gives no output. It creates the TileDB-SOMA database based on the with the `name`, `rds` and `output_folder` elements given in `config.yaml` (see section [Creating config.yaml]).

### Updating the summary 

The `dataset_summary.txt` file can be easily updated with the code in `data/script/update_summary.R`. It automatically searches for all available `config.yaml` in each subfolder of `data/db/`. It retrieves the mandatory elements (see section [Creating config.yaml]), summarizes them in a table, to finally write it in `dataset_summary.txt`. 

It can also be used to modify some information in `dataset_summary.txt`. For example to change a description, first modify the corresponding `config.yaml` and then re-run `data/script/update_summary.R`. 

### Making the change effective online

This describes how to add a database locally. You should then check that everything is working fine. Once you are ready, you should follow the steps written in the [deployment documentation](doc/deployment.html). 

# Good pratices 

To develop the app efficiently, there are some good practice that need to be followed. They are presented in the following sections. 

## Git (mandatory)

### Introduction

Git is a version control system used to track changes made to the code over time. It is helpful to:

-   revert/compare with previous versions
-   understand who made changes and why (with commit messages)
-   manage conflicts when various changes were made to the code

It is different from github, which is a git platform service to create, store and manage code. This is the place where you can share code to collaborate, as well as create, assign and track issues, bugs and feature requests.

### Usage in practice

You can pull and push new versions of the app via [github](https://github.com/metzger-chambon/singlecellviz). You must be a member of github's metzger-chambon team to push to the repository.

When you locally make a change in a file and want to apply the changes on github, you need to run the commands (in Terminal, and in the local folder of the app) in the following order:

-   `git add $FILE`: add the changes in the file
-   `git commit -m $MESSAGE`: commit the changes
-   `git push`: push commits on github

When doing a lot of changes, it is good practice to create a new branch (`git branch $BRANCHNAME`), and work on it (`git checkout $BRANCHNAME`), until all changes are made and working, in order to merge the main and new branch (`git checkout master` then, `git merge $BRANCHNAME`).

To practice and learn more about git: <https://www.w3schools.com/git/default.asp>.

## renv (mandatory) {#renv-mandatory}

renv is a R package to create reproducible environments for R projects. Each project has its own independent collection of packages with specific versions.


## testthat (optional) {#testthat-optional}

testthat is a R package to deal with unitary tests. This is advised but not obligatory.


